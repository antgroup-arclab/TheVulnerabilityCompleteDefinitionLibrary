#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <errno.h>
#include <string.h>
#include <string>
#include <vector>
#include <set>
#include <fstream>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <libgen.h>
#define DEBUG
#ifdef DEBUG
#define LOG(fmt, __args...) printf("LOGINFO %13s %4d %s :\t" fmt , __FILE__, __LINE__, __func__, ##__args);
#define LOGRAW(__args...) printf(__args);
#endif
typedef std::vector<std::string> strvec;
typedef std::set<std::string> strset;
class ASTC {
public:
    ASTC(): mRet(-1), mOriginRet(-1), mOnlyCompile(false), mOutFile("a.out") {}
    void print();
    int exec();
    int parseArgs();
    int doASTCompile();
    int doASTLink();
    void searchLibs();
    strvec mArgs;
    std::string mBaseName;
    std::string mRealCCPath;
    std::string mRealARPath;
    int mRet;
    int mOriginRet;
    bool mOnlyCompile;
    
    strvec mCompileFlags;
    strvec mLinkFlags;
    strvec mSourceFiles;
    strvec mLinkFiles;
    std::string mOutFile;

    strvec mLibSearchDirs;
    strvec mLibLinkNames;
};
void ASTC::print() {
    LOG("mArgs = ");
    size_t i;
    for (i = 0; i < mArgs.size(); ++i) {
        LOGRAW("%s ",mArgs[i].c_str());
    }
    LOGRAW("\n");
    LOG("mBaseName = %s\n", mBaseName.c_str());
    LOG("mRealCCPath = %s\n", mRealCCPath.c_str());
    LOG("mRealARPath = %s\n", mRealARPath.c_str());
}
int exec_binary(char *real_binary, char **argv, int *pret) {
    pid_t pid = vfork();
    if (pid == 0) {
        if (real_binary == NULL) {
            execvp(argv[0], argv);
            LOG("execvp failed %s\n", strerror(errno));
            _exit(-1);
            return -1;
        } else {
            execv(real_binary, argv);
            LOG("execvp failed %s\n", strerror(errno));
            _exit(-1);
            return -1;
        }
    } else if (pid >= 0) {
        LOG("child process started pid %d\n", pid);
        int status = -1;
        if (waitpid(pid, &status, 0) != pid) {
            LOG("waitpid %d failed %s\n", pid, strerror(errno));
            return -1;
        }
        LOG("child process finished pid %d\n", pid);
        if (WIFEXITED(status)) {
            *pret = WEXITSTATUS(status);
        } else if (WIFSIGNALED(status) || WIFSTOPPED(status)) {
            LOG("child prcess is signaled!!!\n");
            return -1;
        }
    } else {
        LOG("vfork failed %s\n", strerror(errno));
        return -1;
    }
    return 0;
}
int ASTC::exec() {
    size_t argv_size = sizeof(char *) * (mArgs.size() + 1);
    char **argv = (char **)malloc(argv_size);
    if (argv == NULL) {
        LOG("malloc failed\n");
        return -1;
    }
    memset(argv, 0, argv_size);
    argv[0] = (char *)mBaseName.c_str();
    size_t i;
    for(i = 1; i < mArgs.size(); ++i) {
        argv[i] = (char *)mArgs[i].c_str();
    }
    char *real_binary = NULL;
    if (mBaseName == "ar" && !mRealARPath.empty())
        real_binary = (char *)mRealARPath.c_str();
    else if (!mRealCCPath.empty())
        real_binary = (char *)mRealCCPath.c_str();
    if (exec_binary(real_binary, argv, &mRet) != 0) {
        LOG("exec_binary failed\n");
        free(argv);
        return -1;
    }
    free(argv);
    return 0;
}
bool isArchive(const char *path) {
    FILE *fp = fopen(path, "r");
    if (fp == NULL)
        return false;
    char head[8];
    if (fread(head, sizeof(head), 1, fp) != 1) {
        fclose(fp);
        return false;
    }
    fclose(fp);
    if (memcmp(head, "!<arch>\n", sizeof(head)) == 0)
        return true;
    return false;
}
bool isMachO(const char *path) {
    FILE *fp = fopen(path, "r");
    if (fp == NULL)
        return false;
    char head[4];
    if (fread(head, sizeof(head), 1, fp) != 1) {
        fclose(fp);
        return false;
    }
    fclose(fp);
    if (memcmp(head, "\xcf\xfa\xed\xfe", sizeof(head)) == 0)
        return true;
    return false;
}
bool isELF(const char *path) {
    FILE *fp = fopen(path, "r");
    if (fp == NULL)
        return false;
    char head[4];
    if (fread(head, sizeof(head), 1, fp) != 1) {
        fclose(fp);
        return false;
    }
    fclose(fp);
    if (memcmp(head, "\x7f\x45\x4c\x46", sizeof(head)) == 0)
        return true;
    return false;
}
static inline bool starts_with(std::string &s, const char *x) {
    return s.rfind(x, 0) == 0;
}
static inline bool ends_with(std::string &s, const char *x) {
    size_t len = strlen(x);
    if (s.size() < len)
        return false;
    if (s.rfind(x) == s.size() - len)
        return true;
    return false;
}
bool isRegularFile(std::string &s) {
    char *path = NULL;
    if ((path = realpath(s.c_str(), NULL)) == NULL)
        return false;
    struct stat st;
    if (stat(path, &st) != 0) {
        free(path);
        return false;
    }
    free(path);
    if ((st.st_mode & S_IFMT) == S_IFREG)
        return true;
    return false;
}
bool isSourceFile(std::string &s) {
    /*
    return     !isArchive(s.c_str()) 
            && !isMachO(s.c_str()) 
            && !isELF(s.c_str())
            && !ends_with(s, ".dylib")
            && !ends_with(s, ".so")
            && !ends_with(s, ".a")
            && !ends_with(s, ".h")
            && !ends_with(s, ".hxx")
            && !ends_with(s, ".hpp")
            && !ends_with(s, ".inc")
            && !ends_with(s, ".pch");
            */
    return     !isArchive(s.c_str()) 
            && !isMachO(s.c_str()) 
            && !isELF(s.c_str())
            && (   ends_with(s, ".c") 
                || ends_with(s, ".C") 
                || ends_with(s, ".c++") 
                || ends_with(s, ".C++") 
                || ends_with(s, ".cc") 
                || ends_with(s, ".CC") 
                || ends_with(s, ".cxx") 
                || ends_with(s, ".CXX")
                || ends_with(s, ".Cxx")
                || ends_with(s, ".cp")
                || ends_with(s, ".cpp")
                || ends_with(s, ".Cpp")
                || ends_with(s, ".CPP")
                || ends_with(s, ".m")
                || ends_with(s, ".mm")
                || ends_with(s, ".M")
                || ends_with(s, ".MM")
                );
}
int ASTC::parseArgs() {
    if (mBaseName != "ar") {
        mCompileFlags.push_back("-fno-delayed-template-parsing");
        mCompileFlags.push_back("-fpch-instantiate-templates");
        mCompileFlags.push_back("-emit-ast");
        for (std::string &s : mArgs) {
            if (s == "-c") {
                mOnlyCompile = true;
                break;
            }
        }
        if (mOnlyCompile) { // only compile
            auto it = mArgs.begin();
            ++it;
            for(;it != mArgs.end();++it) {
                if (*it == "-o") {
                    ++it;
                    if (it == mArgs.end()) {
                        LOG("bad -o arg.\n");
                        return -1;
                    }
                    mOutFile = *it;
                    continue;
                }
                if (*it == "-c")
                    continue;
                if (it->c_str()[0] != '-' 
                        && isSourceFile(*it)
                        && isRegularFile(*it)
                        ) {
                    mSourceFiles.push_back(*it);
                    continue;
                }
                mCompileFlags.push_back(*it);
            }
        } else { // link or (compile and link)
            size_t idx = 0;
            auto it = mArgs.begin();
            ++it;++idx;
            for(;it != mArgs.end();++it,++idx) {
                if (*it == "-o") {
                    ++it;++idx;
                    if (it == mArgs.end()) {
                        LOG("bad -o arg.\n");
                        return -1;
                    }
                    mOutFile = *it;
                    continue;
                }
                if (it->c_str()[0] != '-') {
                    if (isRegularFile(*it)) {
                        std::string mayASTFile = *it + ".ast";
                        std::string mayASTListFile = *it + ".astlist";
                        if (access(mayASTFile.c_str(), R_OK) == 0) {
                            mLinkFiles.push_back(mayASTFile);
                            continue;
                        } else if (access(mayASTListFile.c_str(), R_OK) == 0) {
                            mLinkFiles.push_back(mayASTListFile);
                            continue;
                        } else if (isSourceFile(*it)) {
                            mSourceFiles.push_back(*it);
                            continue;
                        }
                    }
                }
                // not drop diff flags now
                mCompileFlags.push_back(*it);
                mLinkFlags.push_back(*it);

                if (starts_with(*it, "-L")) {
                    if (it->size() > 2) {
                        mLibSearchDirs.push_back(it->substr(2));
                    } else {
                        ++it;++idx;
                        if (it == mArgs.end()) {
                            LOG("bad -L arg.\n");
                            return -1;
                        }
                        mLibSearchDirs.push_back(*it);
                    }
                } else if (starts_with(*it, "-l")) {
                    if (it->size() > 2) {
                        mLibLinkNames.push_back(it->substr(2));
                    } else {
                        ++it;++idx;
                        if (it == mArgs.end()) {
                            LOG("bad -l arg.\n");
                            return -1;
                        }
                        mLibLinkNames.push_back(*it);
                    }
                }
            }
            searchLibs();
        }
    } else { // ar link
        bool found = false;
        size_t idx = 0;
        auto it = mArgs.begin();
        while(it != mArgs.end()) {
            if (it->c_str()[0] != '-' && idx > 1) {
                if (!found) {
                    mOutFile = *it;
                    found = true;
                } else {
                    std::string mayASTFile = *it + ".ast";
                    std::string mayASTListFile = *it + ".astlist";
                    if (access(mayASTFile.c_str(), R_OK) == 0) {
                        mLinkFiles.push_back(mayASTFile);
                    } else if (access(mayASTListFile.c_str(), R_OK) == 0) {
                        mLinkFiles.push_back(mayASTListFile);
                    }
                }
            }
            ++it;++idx;
        }
    }
    return 0;
}
int ASTC::doASTCompile() {
    if (mOnlyCompile) {
        if (mSourceFiles.size() != 1) {
            LOG("multi source file detected with -c option!!!\n");
            return -1;
        }
        mArgs.clear();
        mArgs.push_back(mBaseName);
        for (std::string &f : mCompileFlags) {
            mArgs.push_back(f);
        }
        mArgs.push_back("-c");
        mArgs.push_back(mSourceFiles[0]);
        mArgs.push_back("-o");
        mArgs.push_back(mOutFile + ".ast");
        LOG("do ast only compile\n");
        print();
        if(exec() != 0) {
            LOG("exec failed\n");
            return -1;
        }
        return 0;
    }
    for(std::string &s : mSourceFiles) {
        mArgs.clear();
        mArgs.push_back(mBaseName);
        for (std::string &f : mCompileFlags) {
            mArgs.push_back(f);
        }
        mArgs.push_back("-c");
        mArgs.push_back(s);
        mArgs.push_back("-o");
        std::string outfile = mOutFile + "-" + s + ".ast";
        mArgs.push_back(outfile);
        LOG("do ast compile file : %s\n", s.c_str());
        print();
        if(exec() != 0) {
            LOG("exec failed\n");
            return -1;
        }
        // add output ast file to linkfiles after success compile
        mLinkFiles.push_back(outfile); 
    }
    return 0;
}
int ASTC::doASTLink() {
    // START get real path
    char path[PATH_MAX],tmp[PATH_MAX];
    dirname_r(mOutFile.c_str(), tmp);
    if (realpath(tmp, path) == NULL) {
        LOG("realpath failed %s\n", strerror(errno));
        return -1;
    }
    path[sizeof(path) - 1] = '\0';
    std::string dir(path);
    basename_r(mOutFile.c_str(), tmp);
    mOutFile = dir + "/" + tmp;

    mOutFile += ".astlist";

    auto it = mLinkFiles.begin();
    while (it != mLinkFiles.end()) {
        char *path = NULL;
        if ((path = realpath(it->c_str(), NULL)) == NULL) {
            LOG("realpath failed %s\n", strerror(errno));
            return -1;
        }
        *it = path;
        free(path);
        if (*it == mOutFile) {
            LOG("link in and out must not equal !!! drop %s from mLinkFiles\n", it->c_str());
            it = mLinkFiles.erase(it);
        } else {
            ++it;
        }
    }
    LOG("mOutFile = %s\n", mOutFile.c_str());
    // END 
    // START make unique astlist
    strset linkfiles;
    for (std::string &f : mLinkFiles) {
        LOG("linkfile = %s\n", f.c_str());
        if (ends_with(f, ".astlist")) {
            std::ifstream is;
            is.open(f.c_str());
            if ((is.rdstate() & std::ifstream::failbit) != 0) {
                LOG("open %s failed %s\n", f.c_str(), strerror(errno));
                return -1;
            }
            while(1) {
                char path[PATH_MAX];
                is.getline(path, PATH_MAX);
                if (!is.good())
                    break;
                auto setret = linkfiles.insert(path);
                if (setret.second) {
                    LOG("       unique    inner file : %s\n", path);
                } else {
                    LOG("       duplicate inner file : %s\n", path);
                }

            }
            is.close();
        } else {
            auto setret = linkfiles.insert(f);
            if (setret.second) {
                LOG("       unique    link file : %s\n", f.c_str());
            } else {
                LOG("       duplicate link file : %s\n", f.c_str());
            }
        }
    }
    // END
    // START write to .astlist
    std::ofstream os;
    os.open(mOutFile.c_str());
    if ((os.rdstate() & std::ofstream::failbit) != 0) {
        LOG("open %s failed %s\n", mOutFile.c_str(), strerror(errno));
        return -1;
    }
    for (const std::string &f : linkfiles) {
        LOG("final linkfile = %s\n", f.c_str());
        os.write(f.c_str(), f.size());
        os.write("\n", 1);
    }
    os.close();
    // END
    return 0;
}
void ASTC::searchLibs() {
    for (std::string &n : mLibLinkNames) {
        for (std::string &d : mLibSearchDirs) {
            std::string file;
            file = d + "/" + n + ".ast";
            if (isRegularFile(file)) {
                mLinkFiles.push_back(file);
                break;
            }
            file = d + "/" + "lib" + n + ".a.astlist";
            if (isRegularFile(file)) {
                mLinkFiles.push_back(file);
                break;
            }
        }
    }
}
int main(int argc, char **argv) {
    ASTC cc;
    cc.mBaseName = basename(argv[0]);
    size_t i;
    for (i = 0; i < argc; ++i) {
        cc.mArgs.push_back(argv[i]);
    }
    char *real_cc = getenv("REAL_CC_PATH");
    if (real_cc != NULL) {
        cc.mRealCCPath = real_cc;
    }
    char *real_ar = getenv("REAL_AR_PATH");
    if (real_ar != NULL) {
        cc.mRealARPath = real_ar;
    }
    cc.print();
    if (cc.exec() != 0) {
        LOG("execute origin command failed\n");
        return -1;
    }
    cc.mOriginRet = cc.mRet;
    if(cc.parseArgs() != 0) {
        LOG("parseArgs failed\n");
        return -1;
    }
    if (cc.mSourceFiles.size() != 0) {
        LOG("do ast compile...\n");
        cc.doASTCompile();
    }
    if (cc.mLinkFiles.size() != 0) {
        LOG("do ast link...\n");
        cc.doASTLink();
    }
    return cc.mOriginRet;
}
