#include "Definition.h"
using namespace vcd;
//https://github.com/github/codeql/blob/main/cpp/ql/src/experimental/Security/CWE/CWE-415/DoubleFree.ql
int double_free() {
    //_Znam new[], _Znwm new, malloc, calloc, _ZdaPv delete[], _ZdlPv delete, free
    Definition::sp d = Definition::newDefinition("double free");
    FuncExpr allocFunc = FuncExpr(d).full_name(d->regex("(operator new(\\[\\])?\\(unsigned long\\)|_?(malloc|calloc|realloc))"));
    Expr::wp regex = d->regex("(operator delete(\\[\\])?\\(void\\*\\)|_?free)");
    FuncExpr freeFuncFirst = FuncExpr(d).full_name(regex);
    FuncExpr freeFuncSecond = FuncExpr(d).full_name(regex);
    Expr::wp val = d->value();
    d->path((
        d->path_continuous((Operand(val) = allocFunc(), val != d->null_ptr())),
        freeFuncFirst(val),
        freeFuncSecond(val)
    ));
    d->printRawExpr();
    d->printTree();
    if(d->validate() != 0) {
        printf("This definition \"%s\" is not valid\n", d->mName.c_str());
        return -1;
    }
    return 0;
}
int integer_overflow() {
    Definition::sp d = Definition::newDefinition("integer overflow", 
            "clang and gcc pratically use 32bit and 64bit integer only.");
    Expr::wp u32max = d->u32(UINT32_MAX);
    Expr::wp u64max = d->u64(UINT64_MAX);
    Expr::wp s32max = d->s32(INT32_MAX);
    Expr::wp s64max = d->s64(INT64_MAX);
    Expr::wp s32min = d->s32(INT32_MIN);
    Expr::wp s64min = d->s64(INT64_MIN);
    Expr::wp u32zero = d->u32(0);
    Expr::wp u64zero = d->u64(0);
    Expr::wp s32zero = d->s32(0);
    Expr::wp s64zero = d->s64(0);
    Expr::wp s32one = d->s32(1);
    Expr::wp s64one = d->s64(1);
    Expr::wp u32a = d->value(d->u32());
    Expr::wp u32b = d->value(d->u32());
    Expr::wp s32a = d->value(d->s32());
    Expr::wp s32b = d->value(d->s32());
    Expr::wp u64a = d->value(d->u64());
    Expr::wp u64b = d->value(d->u64());
    Expr::wp s64a = d->value(d->s64());
    Expr::wp s64b = d->value(d->s64());
    d->path(
           d->path_continuous((u32a > u32max - u32b , Operand(u32a) + u32b))
        || d->path_continuous((u64a > u64max - u64b , Operand(u64a) + u64b))
        || d->path_continuous((u32b > u32a, Operand(u32a) - u32b))
        || d->path_continuous((u64b > u64a, Operand(u64a) - u64b))
        || d->path_continuous(((u32b != u32zero) && (u32a > u32max / u32b) , Operand(u32a) * u32b))
        || d->path_continuous(((u64b != u64zero) && (u64a > u64max / u64b) , Operand(u64a) * u64b))
        || d->path_continuous((
                   (s32b > s32zero && (s32a > s32max - s32b)) 
                || (s32b < s32zero && (s32a < s32min - s32b)), Operand(s32a) + s32b
            ))
        || d->path_continuous((
                   (s64b > s64zero && (s64a > s64max - s64b)) 
                || (s64b < s64zero && (s64a < s64min - s64b)), Operand(s64a) + s64b
            ))
        || d->path_continuous((
                   (s32b > s32zero && (s32a < s32min + s32b)) 
                || (s32b < s32zero && (s32a > s32max + s32b)), Operand(s32a) - s32b
            ))
        || d->path_continuous((
                   (s64b > s64zero && (s64a < s64min + s64b)) 
                || (s64b < s64zero && (s64a > s64max + s64b)), Operand(s64a) - s64b
            ))
        || d->path_continuous((
                   (s32a > s32zero && s32b > s32zero && (s32a > s32max / s32b))
                || (s32a == s32min && (s32b < s32zero || s32b > s32one))
                || (s32b == s32min && (s32a < s32zero || s32a > s32one))
                || (s32a != s32min && s32a < s32zero && ((s32b < s32zero && (s32b < s32max / s32a)) 
                                                      || (s32b > s32zero && (s32b > (s32min + s32one) / s32a))))
                || (s32b != s32min && s32b < s32zero && ((s32a < s32zero && (s32a < s32max / s32b)) 
                                                      || (s32a > s32zero && (s32a > (s32min + s32one) / s32b))))
                , Operand(s32a) * s32b
            ))
        || d->path_continuous((
                   (s64a > s64zero && s64b > s64zero && (s64a > s64max / s64b))
                || (s64a == s64min && (s64b < s64zero || s64b > s64one))
                || (s64b == s64min && (s64a < s64zero || s64a > s64one))
                || (s64a != s64min && s64a < s64zero && ((s64b < s64zero && (s64b < s64max / s64a)) 
                                                      || (s64b > s64zero && (s64b > (s64min + s64one) / s64a))))
                || (s64b != s64min && s64b < s64zero && ((s64a < s64zero && (s64a < s64max / s64b)) 
                                                      || (s64a > s64zero && (s64a > (s64min + s64one) / s64b))))
                , Operand(s64a) * s64b
            ))
    );
    d->printRawExpr();
    d->printTree();
    if(d->validate() != 0) {
        printf("This definition \"%s\" is not valid\n", d->mName.c_str());
        return -1;
    }
    return 0;
}
//https://github.com/github/codeql/blob/main/cpp/ql/src/Critical/UseAfterFree.ql
static Expr::wp makeUAF(Definition::sp d, Expr::wp allocInvoke, Expr::wp allocSize, FuncExpr &freeFunc) {
    Expr::wp ptr = d->value();
    Expr::wp ptro = d->value();
    return  d->path((
                d->path_continuous((
                    Operand(ptr) = allocInvoke,
                    ptr != d->null_ptr(),
                    Operand(ptro) = d->otaint(ptr)
                )),
                freeFunc(ptr),
                d->path_continuous((
                    ptro >= ptr && ptro < (ptr + allocSize),
                    d->optr_read(ptro) || d->optr_write(ptro)
                ))
            ));
}
int use_after_free() {
    Definition::sp d = Definition::newDefinition("use after free");
    FuncExpr mallocFunc = FuncExpr(d).full_name(d->regex("(operator new(\\[\\])?\\(unsigned long\\)|_?malloc)"));
    FuncExpr callocFunc = FuncExpr(d).full_name(d->regex("_?calloc"));
    FuncExpr reallocFunc = FuncExpr(d).full_name(d->regex("_?realloc"));
    FuncExpr freeFunc = FuncExpr(d).full_name(d->regex("(operator delete(\\[\\])?\\(void\\*\\)|_?free)"));
    Expr::wp msize = d->value();
    Expr::wp csize = d->value();
    Expr::wp cnum = d->value();
    Expr::wp rsize = d->value();

    d->path(
            makeUAF(d, mallocFunc(msize), msize, freeFunc)
         || makeUAF(d, callocFunc((cnum, csize)), cnum * csize, freeFunc)
         || makeUAF(d, reallocFunc((d->value(), rsize)), rsize, freeFunc)
    );
    d->printRawExpr();
    d->printTree();
    if(d->validate() != 0) {
        printf("This definition \"%s\" is not valid\n", d->mName.c_str());
        return -1;
    }
    return 0;

}
int bad() {
    Definition::sp d = Definition::newDefinition("bad");
    d->printRawExpr();
    if(d->validate() != 0) {
        printf("This definition \"%s\" is not valid\n", d->mName.c_str());
        return -1;
    }
    return 0;
}
///*
int main(int argc, char **argv) {
    double_free();
    integer_overflow();
    use_after_free();
    bad();
    return 0;
}
//*/
extern "C" int createDefinitions(void *defs) {
    Definition::spvec *ds = (Definition::spvec *)defs;
    Definition::sp d = Definition::newDefinition("test", "test desc");
    FuncExpr allocFunc = FuncExpr(d).full_name(d->regex("(operator new(\\[\\])?\\(unsigned long\\)|_?(malloc|calloc|realloc))"));
    FuncExpr freeFunc = FuncExpr(d).full_name(d->regex("(operator delete(\\[\\])?\\(void\\*\\)|_?free)"));
    FuncExpr dtorFunc = FuncExpr(d).full_name(d->regex(".*::~.*"));
    d->path((allocFunc(), freeFunc(), dtorFunc()));
    ds->push_back(d);
    return 0;

    InvokeExpr invoke = InvokeExpr(d, allocFunc).has_arg(d->value(d->u64()));
    TypeExpr type = TypeExpr(d)
        .field(VarExpr(d).full_name(d->utf8("exampleField")))
        .base(TypeExpr(d).full_name(d->utf8("TestNamespace::TestClass")));

    Expr::wp unsignedType = d->u8() || d->u16() || d->u32() || d->u64();
    Expr::wp v1 = d->value(unsignedType);
    Expr::wp v2 = d->value(unsignedType);

    TypeExpr notBaseType = TypeExpr(d)
        .base(!TypeExpr(d).full_name(d->utf8("TestNamespace::TestClass")));
}
