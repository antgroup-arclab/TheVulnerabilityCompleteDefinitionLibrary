#ifndef DEFINITION_H
#define DEFINITION_H
#include <list>
#include <set>
#include <vector>
#include <map>
#include <string>
#include <memory>
#include <cstdint>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <cstdio>
namespace vcd {
/*
class  {
public:
    (){}
    virtual ~(){}
protected:
private:
};
*/
class Definition;
class Expr {
public:
    typedef std::shared_ptr<Expr> sp;
    typedef std::set<Expr::sp> spset;
    typedef std::vector<Expr::sp> spvec;
    typedef std::weak_ptr<Expr> wp;
    typedef std::vector<Expr::wp> wpvec;
    struct WeakPtrCompare {
        bool operator() (const Expr::wp &lhs, const Expr::wp &rhs) const {
            return lhs.lock() < rhs.lock();
        }
    };
    typedef std::set<Expr::wp, WeakPtrCompare> wpset;
    typedef std::weak_ptr<Definition> defwp;
    friend class Definition;
    enum Type {
        OBNOT, // operation bitwise
        OBOR,
        OBAND,
        OBXOR,
        OBLEFTSHIFT,
        OBRIGHTSHIFT,
        OPLUS, // number
        OSUB,
        OMULT,
        ODIV,
        OREM,
        OSMOD,
        OLT,// comparison
        OLE,
        OGT,
        OGE,
        OEQ,
        ONOT,// logic
        OAND,
        OOR,
        OASSIGN, // program
        OCAST,
        OREAD,
        OWRITE,
        OPTR_READ, // access pointer 
        OPTR_WRITE,
        OINVOKE,
        ORETURN,
        OIF,
        OFOR,
        OFOR_EACH,
        OWHILE,
        ODO_WHILE,
        OBREAK,
        OCONTINUE,
        OARRAY_ELEMENT, // access array element
        OADDRESS, // access address of variable or member of variable
        OMEMBER, // access member from class
        OOFFSET_OF,
        OSIZE_OF,
        OTAINT,
        BNOT, // constraint calculate
        BOR,
        BAND,
        BXOR,
        BLEFTSHIFT,
        BRIGHTSHIFT,
        PLUS,
        SUB,
        MULT,
        DIV,
        REM,
        LT,
        LE,
        GT,
        GE,
        EQ,
        ARRAY_ELEMENT, // access array element
        MEMBER, // access member
        OFFSET_OF,
        SIZE_OF,
        CAST, 
        NOT, // constraint logic
        AND,
        OR,
        VOID, // basic type or data with type 
        BOOL,
        U8,
        U16,
        U32,
        U64,
        U128,
        S8,
        S16,
        S32,
        S64,
        S128,
        F32,
        F64,
        UINTPTR,
        BITS,
        UTF8_STRING,
        UTF16_STRING,
        ARRAY,
        POINTER,
        RAWDATA,
        REGEX, // object // regex string
        TIMES, // meet times of operation or 
        NAME, // name without namespace
        FULL_NAME, // namespace::name
        TYPE, // complex type
        TYPE_BASE,
        TYPE_DERIVED,
        TYPE_INNER,
        TYPE_OUTER,
        TYPE_FIELD,
        TYPE_METHOD,
        NULL_PTR,
        UNDEFINED_ADDRESS,
        LITERAL, //initial values in program
        VALUE, // as a variable or literal
        VARIABLE, // has type and name
        FUNCTION,
        EXPRLIST,
        MEMBER_OF, // in function or variable , 
        LOCAL, // in stack or heap
        GLOBAL, // in program image
        IN, // for operation or function, can has index, must has variable
        OUT,
        PATH_INTERVAL, // consist of list of operation or constraint
        PATH_CONTINUOUS,
        NO_MORE,
        EXIST,
        CXX_EXTERN_C, // c++ language
        CXX_CLASS,
        CXX_ENUM,
        CXX_STRUCT,
        CXX_UNION,
        CXX_MODIFY_CONST,
        CXX_MODIFY_EXPLICIT,
        CXX_MODIFY_EXPORT,
        CXX_MODIFY_EXTERN,
        CXX_MODIFY_FRIEND,
        CXX_MODIFY_INLINE,
        CXX_MODIFY_MUTABLE,
        CXX_MODIFY_NOEXCEPT,
        CXX_MODIFY_VIRTUAL,
        CXX_MODIFY_VOLATILE,
        CXX_MODIFY_PRIVATE,
        CXX_MODIFY_PROTECTED,
        CXX_MODIFY_PUBLIC,
        CXX_MODIFY_STATIC,
    };
    union Number {
        bool b;
        uint8_t u8;
        uint16_t u16;
        uint32_t u32;
        uint64_t u64;
        int8_t s8;
        int16_t s16;
        int32_t s32;
        int64_t s64;
        float flt;
        double dbl;
    };
    Expr(Type type, defwp def) : mType(type), mDef(def) {}
    Expr(const Expr &o) {
        mType = o.mType;
        mNexts = o.mNexts;
        mPrevs = o.mPrevs;
        mPayload = o.mPayload;
        mDef = o.mDef;
    }
    virtual ~Expr() {}
    void setUTF8(const char *str) {
        size_t len = strlen(str);
        mPayload.resize(len + 1);
        memcpy(mPayload.data(), str, len + 1);
    }
    char *getUTF8() {
        return (char *)mPayload.data();
    }
#define EXPR_NUM(name, type) \
    void set##name(type n) {\
        mPayload.resize(sizeof(n));\
        memcpy(mPayload.data(), &n, sizeof(n));\
    }\
    type get##name() {\
        return *(type *)mPayload.data();\
    }
EXPR_NUM(U8, uint8_t);
EXPR_NUM(U16, uint16_t);
EXPR_NUM(U32, uint32_t);
EXPR_NUM(U64, uint64_t);
EXPR_NUM(S8, int8_t);
EXPR_NUM(S16, int16_t);
EXPR_NUM(S32, int32_t);
EXPR_NUM(S64, int64_t);
EXPR_NUM(BOOL, bool);
EXPR_NUM(F32, float);
EXPR_NUM(F64, double);
EXPR_NUM(UINTPTR, uint64_t);
    static bool isOperation(Expr::Type type) {
        return (type >= OBNOT && type <= OTAINT);
    }
    static bool isConstraint(Expr::Type type) {
        return (type >= BNOT && type <= OR);
    }
    static bool isConstraintCalculate(Expr::Type type) {
        return (type >= BNOT && type <= CAST);
    }
    static bool isConstraintLogic(Expr::Type type) {
        return (type >= NOT && type <= OR);
    }
    static bool isOperand(Expr::Type type) {
        return (type >= VOID && type <= RAWDATA) || (type >= NULL_PTR && type <= FUNCTION);
    }
    static bool isOperandOrExist(Expr::Type type) {
        return isOperand(type) || type == EXIST;
    }
    static bool isVariableOrExist(Expr::Type type) {
        return type == VARIABLE || type == EXIST;
    }
    static bool isFunctionOrExist(Expr::Type type) {
        return type == FUNCTION || type == EXIST;
    }
    static bool isVarOrFuncOrExist(Expr::Type type) {
        return type == VARIABLE || type == FUNCTION || type == EXIST;
    }
    static bool isOperationOrOperandOrExist(Expr::Type type) {
        return isOperation(type) || isOperand(type) || type == EXIST;
    }
    static bool isConstraintCalculateOrOperandOrExist(Expr::Type type) {
        return isConstraintCalculate(type) || isOperand(type) || type == EXIST;
    }
    static bool isS64OrExist(Expr::Type type) {
        return type == S64 || type == EXIST;
    }
    static bool isPointerOrExist(Expr::Type type) {
        return type == POINTER || type == EXIST;
    }
    static bool isPathOrExist(Expr::Type type) {
        return type == PATH_INTERVAL || type == EXIST;
    }
    static bool isPath(Expr::Type type) {
        return type == PATH_INTERVAL || type == PATH_CONTINUOUS;
    }
    static bool isBasicType(Expr::Type type) {
        return (type >= VOID && type <= RAWDATA);
    }
    static bool isType(Expr::Type type) {
        return (type >= VOID && type <= RAWDATA) || (type == TYPE);
    }
    static bool isTypeOrExist(Expr::Type type) {
        return isType(type) || type == EXIST;
    }
    static bool isComplexTypeOrOperandOrExist(Expr::Type type) {
        return type == TYPE || isOperand(type) || type == EXIST;
    }
    static bool isComplexTypeOrExist(Expr::Type type) {
        return type == TYPE || type == EXIST;
    }
    static bool isTypeOrOperandOrExist(Expr::Type type) {
        return isType(type) || isOperand(type) || type == EXIST;
    }
    static bool isTypeOrOperationOrOperandOrExist(Expr::Type type) {
        return isType(type) || isOperation(type) || isOperand(type) || type == EXIST;
    }
    static bool isCXX(Expr::Type type) {
        return (type >= CXX_EXTERN_C && type <= CXX_MODIFY_STATIC);
    }
    static bool isOCompare(Expr::Type type) {
        return (type >= OLT && type <= OOR);
    }
    static bool isOCompareOrExist(Expr::Type type) {
        return isOCompare(type) || type == EXIST;
    }
    static bool isUTF8OrRegex(Expr::Type type) {
        return type == UTF8_STRING || type == REGEX;
    }
    bool isGoodLogic() {
        if (isConstraintLogic(mType) == false)
            return false;
        if (mType == NOT && mNexts.size() != 1)
            return false;
        else if (mNexts.size() < 2)
            return false;
        return true;
    }

    Type mType;
    wpvec mNexts;
    wpvec mPrevs;
    std::vector<uint8_t> mPayload;
    defwp mDef;
    wp mSelf;
protected:
private:
};
extern const char *ExprTypeNames[];

class Definition {
public:
    typedef std::shared_ptr<Definition> sp;
    typedef std::set<Definition::sp> spset;
    typedef std::vector<Definition::sp> spvec;
    typedef std::weak_ptr<Definition> wp;
    typedef std::vector<Definition::wp> wpvec;
    struct WeakPtrCompare {
        bool operator() (const Definition::wp &lhs, const Definition::wp &rhs) const {
            return lhs.lock() < rhs.lock();
        }
    };
    typedef std::set<Definition::wp, WeakPtrCompare> wpset;
    struct ExprEdge {
        Expr::wp from;
        Expr::wp to;
    };
    struct ExprEdgeCompare {
        bool operator() (const ExprEdge &lhs, const ExprEdge &rhs) const {
            Expr::sp lf = lhs.from.lock();
            Expr::sp rf = rhs.from.lock();
            Expr::sp lt = lhs.to.lock();
            Expr::sp rt = rhs.to.lock();
            if (lf != rf)
                return lf < rf;
            else
                return lt < rt;
        }
    };
    virtual ~Definition() {}
    static sp newDefinition(std::string name, std::string desc = "") {
        sp nd = sp(new Definition(name, desc));
        nd->mSelf = nd;
        return nd;
    }
    Expr::wp newExpr(Expr::Type type);
    Expr::wp copyExpr(Expr::wp o);
    void deleteExpr(Expr::wp e);
    void connectExpr(Expr::wp from, Expr::wp to);
    Expr::wp utf8() {
        return newExpr(Expr::UTF8_STRING);
    }
    Expr::wp utf8(const char *str) {
        size_t len = strlen(str);
        Expr::sp ne = newExpr(Expr::UTF8_STRING).lock();
        ne->mPayload.resize(len + 1);
        memcpy(ne->mPayload.data(), str, len + 1);
        return ne;
    }
    void setUTF8(Expr::wp e, const char *str) {
        size_t len = strlen(str);
        Expr::sp esp = e.lock();
        esp->mPayload.resize(len + 1);
        memcpy(esp->mPayload.data(), str, len + 1);
    }
    char *getUTF8(Expr::wp e) {
        Expr::sp esp = e.lock();
        return (char *)esp->mPayload.data();
    }
    Expr::wp utf16() {
        return newExpr(Expr::UTF16_STRING);
    }
    Expr::wp utf16(const uint16_t *str, size_t count) {
        Expr::sp ne = newExpr(Expr::UTF16_STRING).lock();
        ne->mPayload.resize(sizeof(uint16_t) * count);
        memcpy(ne->mPayload.data(), str, sizeof(uint16_t) * count);
        return ne;
    }
    void setUTF16(Expr::wp e, const uint16_t *str, size_t count) {
        Expr::sp esp = e.lock();
        esp->mPayload.resize(sizeof(uint16_t) * count);
        memcpy(esp->mPayload.data(), str, sizeof(uint16_t) * count);
    }
    uint16_t *getUTF16(Expr::wp e, size_t *pcnt) {
        Expr::sp esp = e.lock();
        *pcnt = esp->mPayload.size() / sizeof(uint16_t);
        return (uint16_t *)esp->mPayload.data();
    }
    Expr::wp regex(const char *str) {// regex must not has utf8, itself is constraint
        size_t len = strlen(str);
        Expr::sp ne = newExpr(Expr::REGEX).lock();
        ne->mPayload.resize(len + 1);
        memcpy(ne->mPayload.data(), str, len + 1);
        return ne;
    }
    Expr::wp bits(Expr::wp bit_count, void *data, size_t size) {
        Expr::sp ne = newExpr(Expr::BITS).lock();
        connectExpr(ne, bit_count);
        ne->mPayload.resize(size);
        memcpy(ne->mPayload.data(), data, size);
        return ne;
    }
    Expr::wp rawdata(void *data, size_t size) {
        Expr::sp ne = newExpr(Expr::RAWDATA).lock();
        ne->mPayload.resize(size);
        memcpy(ne->mPayload.data(), data, size);
        return ne;
    }
#define MAKE_NUM(lcname, name, type) \
    Expr::wp lcname() {\
        return newExpr(Expr::name);\
    }\
    Expr::wp lcname(type n) {\
        Expr::sp ne = newExpr(Expr::name).lock();\
        ne->mPayload.resize(sizeof(n));\
        memcpy(ne->mPayload.data(), &n, sizeof(n));\
        return ne;\
    }\
    void set##name(Expr::wp e, type n) {\
        Expr::sp esp = e.lock();\
        esp->mPayload.resize(sizeof(n));\
        memcpy(esp->mPayload.data(), &n, sizeof(n));\
    }\
    type get##name(Expr::wp e) {\
        Expr::sp esp = e.lock();\
        return *(type *)esp->mPayload.data();\
    }
MAKE_NUM(u8, U8, uint8_t);
MAKE_NUM(u16, U16, uint16_t);
MAKE_NUM(u32, U32, uint32_t);
MAKE_NUM(u64, U64, uint64_t);
MAKE_NUM(s8, S8, int8_t);
MAKE_NUM(s16, S16, int16_t);
MAKE_NUM(s32, S32, int32_t);
MAKE_NUM(s64, S64, int64_t);
MAKE_NUM(b8, BOOL, bool);
MAKE_NUM(f32, F32, float);
MAKE_NUM(f64, F64, double);
MAKE_NUM(uintptr, UINTPTR, uint64_t);

#define MAKE_EXPR0(lcname, name) \
    Expr::wp lcname() {\
        return newExpr(Expr::name);\
    }
MAKE_EXPR0(obreak, OBREAK);
MAKE_EXPR0(ocontinue, OCONTINUE);
MAKE_EXPR0(Void, VOID);
MAKE_EXPR0(local, LOCAL);
MAKE_EXPR0(global, GLOBAL);
MAKE_EXPR0(undefined_address, UNDEFINED_ADDRESS);
MAKE_EXPR0(value, VALUE);
MAKE_EXPR0(no_more, NO_MORE);
MAKE_EXPR0(null_ptr, NULL_PTR);
MAKE_EXPR0(exist, EXIST);
MAKE_EXPR0(cxx_extern_c, CXX_EXTERN_C);

#define MAKE_EXPR1(lcname, name) \
    Expr::wp lcname(Expr::wp e) {\
        Expr::wp ne = newExpr(Expr::name);\
        connectExpr(ne, e);\
        return ne;\
    }
MAKE_EXPR1(oreturn, ORETURN); // obj
MAKE_EXPR1(oread, OREAD); // obj
MAKE_EXPR1(owrite, OWRITE); // obj
MAKE_EXPR1(optr_read, OPTR_READ); // pointer
MAKE_EXPR1(optr_write, OPTR_WRITE); // pointer
MAKE_EXPR1(oaddress, OADDRESS); // obj
MAKE_EXPR1(osize_of, OSIZE_OF); // obj or type
MAKE_EXPR1(otaint, OTAINT); // obj or type
MAKE_EXPR1(bits, BITS); // number, of bits
MAKE_EXPR1(times, TIMES); // number
MAKE_EXPR1(name, NAME); // utf8 or utf16 or regex
MAKE_EXPR1(full_name, FULL_NAME); // utf8 or utf16 or regex
MAKE_EXPR1(literal, LITERAL); // basic type data
MAKE_EXPR1(value, VALUE); // type
MAKE_EXPR1(size_of, SIZE_OF);// type or obj
MAKE_EXPR1(path, PATH_INTERVAL);// constrant or opertion or exprlist
MAKE_EXPR1(path_continuous, PATH_CONTINUOUS);// constrant or opertion or exprlist
MAKE_EXPR1(in, IN); // obj
MAKE_EXPR1(out, OUT); // obj

#define MAKE_EXPR2(lcname, name) \
    Expr::wp lcname(Expr::wp e, Expr::wp e1) {\
        Expr::wp ne = newExpr(Expr::name);\
        connectExpr(ne, e);\
        connectExpr(ne, e1);\
        return ne;\
    }
MAKE_EXPR2(ocast, OCAST); // type, obj
MAKE_EXPR2(owhile, OWHILE); // cond, body
MAKE_EXPR2(odo_while, ODO_WHILE); // body, cond
MAKE_EXPR2(ooffset_of, OOFFSET_OF); // type, field
MAKE_EXPR2(optr_read, OPTR_READ); // pointer, depth
MAKE_EXPR2(optr_write, OPTR_WRITE); // pointer, depth
MAKE_EXPR2(oarray_element, OARRAY_ELEMENT); // arr, idx
MAKE_EXPR2(omember, OMEMBER); // obj, member
MAKE_EXPR2(array_element, ARRAY_ELEMENT); // arr, idx
MAKE_EXPR2(array, ARRAY);// type, depth
MAKE_EXPR2(pointer, POINTER);// type, depth
MAKE_EXPR2(in, IN);// index, obj
MAKE_EXPR2(out, OUT); // index, obj
MAKE_EXPR2(offset_of, OFFSET_OF); // type, member
MAKE_EXPR2(cast, CAST); // type, obj
MAKE_EXPR2(member, MEMBER); // obj, member

#define MAKE_EXPR3(lcname, name) \
    Expr::wp lcname(Expr::wp e, Expr::wp e1, Expr::wp e2) {\
        Expr::wp ne = newExpr(Expr::name);\
        connectExpr(ne, e);\
        connectExpr(ne, e1);\
        connectExpr(ne, e2);\
        return ne;\
    }
MAKE_EXPR3(oif, OIF);// cond, true, false
MAKE_EXPR3(ofor_each, OFOR_EACH); // iter, container, body

#define MAKE_EXPR4(lcname, name) \
    Expr::wp lcname(Expr::wp e, Expr::wp e1, Expr::wp e2, Expr::wp e3) {\
        Expr::wp ne = newExpr(Expr::name);\
        connectExpr(ne, e);\
        connectExpr(ne, e1);\
        connectExpr(ne, e2);\
        connectExpr(ne, e3);\
        return ne;\
    }
MAKE_EXPR4(ofor, OFOR);// init, cond, iter, body

    void printRawExpr();
    void printTree();
    Expr::sp getRoot();
    int validate();
    std::string mName;
    std::string mDesc;
    wp mSelf;
    Expr::spset mExprs;
    std::vector<ExprEdge> mEdges;
    std::map<Expr::Type, Expr::wpvec> mTypeMap;
protected:
private:
    Definition(std::string name, std::string desc = ""): mName(name), mDesc(desc) {}
};
Expr::wp oneArgExpr(Expr::Type, Expr::wp);
Expr::wp twoArgExpr(Expr::Type, Expr::wp, Expr::wp);
Expr::wp operator~ (Expr::wp lhs);
Expr::wp operator| (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator& (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator^ (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator<<(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator>>(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator+ (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator- (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator* (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator/ (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator% (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator< (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator<=(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator> (Expr::wp lhs, Expr::wp rhs);
Expr::wp operator>=(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator==(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator! (Expr::wp lhs);
Expr::wp operator!=(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator&&(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator||(Expr::wp lhs, Expr::wp rhs);
Expr::wp operator, (Expr::wp lhs, Expr::wp rhs);
class Operand { // convert operators from constraints to operations
public:
    Operand(Expr::wp e) : mExpr(e) {}
    operator Expr::wp() { return mExpr;}
    Operand &operator~ () { mExpr = oneArgExpr(Expr::OBNOT, mExpr); return *this;}
    Operand &operator| (Operand &rhs) { mExpr = twoArgExpr(Expr::OBOR, mExpr, rhs.mExpr); return *this;}
    Operand &operator& (Operand &rhs) { mExpr = twoArgExpr(Expr::OBAND, mExpr, rhs.mExpr); return *this;}
    Operand &operator^ (Operand &rhs) { mExpr = twoArgExpr(Expr::OBXOR, mExpr, rhs.mExpr); return *this;}
    Operand &operator<<(Operand &rhs) { mExpr = twoArgExpr(Expr::OBLEFTSHIFT, mExpr, rhs.mExpr); return *this;}
    Operand &operator>>(Operand &rhs) { mExpr = twoArgExpr(Expr::OBRIGHTSHIFT, mExpr, rhs.mExpr); return *this;}
    Operand &operator+ (Operand &rhs) { mExpr = twoArgExpr(Expr::OPLUS, mExpr, rhs.mExpr); return *this;}
    Operand &operator- (Operand &rhs) { mExpr = twoArgExpr(Expr::OSUB, mExpr, rhs.mExpr); return *this;}
    Operand &operator* (Operand &rhs) { mExpr = twoArgExpr(Expr::OMULT, mExpr, rhs.mExpr); return *this;}
    Operand &operator/ (Operand &rhs) { mExpr = twoArgExpr(Expr::ODIV, mExpr, rhs.mExpr); return *this;}
    Operand &operator% (Operand &rhs) { mExpr = twoArgExpr(Expr::OREM, mExpr, rhs.mExpr); return *this;}
    Operand &operator< (Operand &rhs) { mExpr = twoArgExpr(Expr::OLT, mExpr, rhs.mExpr); return *this;}
    Operand &operator<=(Operand &rhs) { mExpr = twoArgExpr(Expr::OLE, mExpr, rhs.mExpr); return *this;}
    Operand &operator> (Operand &rhs) { mExpr = twoArgExpr(Expr::OGT, mExpr, rhs.mExpr); return *this;}
    Operand &operator>=(Operand &rhs) { mExpr = twoArgExpr(Expr::OGE, mExpr, rhs.mExpr); return *this;}
    Operand &operator==(Operand &rhs) { mExpr = twoArgExpr(Expr::OEQ, mExpr, rhs.mExpr); return *this;}
    Operand &operator! () { mExpr = oneArgExpr(Expr::ONOT, mExpr); return *this;}
    Operand &operator!=(Operand &rhs) { mExpr = !twoArgExpr(Expr::OEQ, mExpr, rhs.mExpr); return *this;}
    Operand &operator&&(Operand &rhs) { mExpr = twoArgExpr(Expr::OAND, mExpr, rhs.mExpr); return *this;}
    Operand &operator||(Operand &rhs) { mExpr = twoArgExpr(Expr::OOR, mExpr, rhs.mExpr); return *this;}
    Operand &operator= (Operand &rhs) { mExpr = twoArgExpr(Expr::OASSIGN, mExpr, rhs.mExpr); return *this;}
    Operand &operator[](Operand &rhs) { mExpr = twoArgExpr(Expr::OARRAY_ELEMENT, mExpr, rhs.mExpr); return *this;}
    Operand &operator()(Operand &rhs) { mExpr = twoArgExpr(Expr::OMEMBER, mExpr, rhs.mExpr); return *this;}

    Operand &operator| (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OBOR, mExpr, rhs); return *this;}
    Operand &operator& (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OBAND, mExpr, rhs); return *this;}
    Operand &operator^ (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OBXOR, mExpr, rhs); return *this;}
    Operand &operator<<(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OBLEFTSHIFT, mExpr, rhs); return *this;}
    Operand &operator>>(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OBRIGHTSHIFT, mExpr, rhs); return *this;}
    Operand &operator+ (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OPLUS, mExpr, rhs); return *this;}
    Operand &operator- (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OSUB, mExpr, rhs); return *this;}
    Operand &operator* (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OMULT, mExpr, rhs); return *this;}
    Operand &operator/ (Expr::wp rhs) { mExpr = twoArgExpr(Expr::ODIV, mExpr, rhs); return *this;}
    Operand &operator% (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OREM, mExpr, rhs); return *this;}
    Operand &operator< (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OLT, mExpr, rhs); return *this;}
    Operand &operator<=(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OLE, mExpr, rhs); return *this;}
    Operand &operator> (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OGT, mExpr, rhs); return *this;}
    Operand &operator>=(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OGE, mExpr, rhs); return *this;}
    Operand &operator==(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OEQ, mExpr, rhs); return *this;}
    Operand &operator!=(Expr::wp rhs) { mExpr = !twoArgExpr(Expr::OEQ, mExpr, rhs); return *this;}
    Operand &operator&&(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OAND, mExpr, rhs); return *this;}
    Operand &operator||(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OOR, mExpr, rhs); return *this;}
    Operand &operator= (Expr::wp rhs) { mExpr = twoArgExpr(Expr::OASSIGN, mExpr, rhs); return *this;}
    Operand &operator[](Expr::wp rhs) { mExpr = twoArgExpr(Expr::OARRAY_ELEMENT, mExpr, rhs); return *this;}
    Operand &operator()(Expr::wp rhs) { mExpr = twoArgExpr(Expr::OMEMBER, mExpr, rhs); return *this;}
private:
    Expr::wp mExpr;
};
class FuncExpr {
public:
    typedef std::shared_ptr<FuncExpr> sp;
    typedef std::weak_ptr<FuncExpr> wp;
    FuncExpr(Definition::sp dsp) : mDef(dsp), mArgCnt(0), mRetCnt(0) {
        mExpr = mDef->newExpr(Expr::FUNCTION);
    }
    FuncExpr &name(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->name(e));
        return *this;
    }
    FuncExpr &full_name(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->full_name(e));
        return *this;
    }
    FuncExpr &has_path(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->path(e));
        return *this;
    }
    FuncExpr &has_arg(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->in(e));
        return *this;
    }
    FuncExpr &add_arg(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->in(mDef->s64(mArgCnt), e));
        mArgCnt++;
        return *this;
    }
    FuncExpr &set_arg(Expr::wp index, Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->in(index, e));
        return *this;
    }
    FuncExpr &has_return(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->out(e));
        return *this;
    }
    FuncExpr &add_return(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->out(mDef->s64(mRetCnt), e));
        mRetCnt++;
        return *this;
    }
    FuncExpr &set_return(Expr::wp index, Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->out(index, e));
        return *this;
    }
    FuncExpr &add_expr(Expr::wp e) {
        mDef->connectExpr(mExpr, e);
        return *this;
    }
    FuncExpr &member_of(Expr::wp type) {
        Expr::wp wrapper = mDef->newExpr(Expr::MEMBER_OF);
        mDef->connectExpr(wrapper, type);
        mDef->connectExpr(mExpr, wrapper);
        return *this;
    }
    FuncExpr &flag(Expr::wp e) { // local , global , cxx_modify_const ...
        mDef->connectExpr(mExpr, e);
        return *this;
    }
    operator Expr::wp() {
        return mExpr;
    }
    Expr::wp operator() (Expr::wp exprlist) {
        Expr::wp invoke = mDef->newExpr(Expr::OINVOKE);
        mDef->connectExpr(invoke, mExpr);
        Expr::sp el = exprlist.lock();
        if (el->mType == Expr::EXPRLIST) {
            size_t argCnt = 0;
            for (Expr::wp e : el->mNexts) {
                mDef->connectExpr(invoke, mDef->in(mDef->s64(argCnt), e)); 
                argCnt++;
            }
        } else {
            mDef->connectExpr(invoke, mDef->in(mDef->s64(0), exprlist));
        }
        return invoke;
    }
    Expr::wp operator() () {
        Expr::wp invoke = mDef->newExpr(Expr::OINVOKE);
        mDef->connectExpr(invoke, mExpr);
        return invoke;
    }
private:
    Definition::sp mDef;
    Expr::wp mExpr;
    size_t mArgCnt;
    size_t mRetCnt;
};
class InvokeExpr {
public:
    typedef std::shared_ptr<InvokeExpr> sp;
    typedef std::weak_ptr<InvokeExpr> wp;
    InvokeExpr(Definition::sp dsp, Expr::wp func) : mDef(dsp), mArgCnt(0) {
        mExpr = mDef->newExpr(Expr::FUNCTION);
        mDef->connectExpr(mExpr, func);
    }
    InvokeExpr &has_arg(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->in(e));
        return *this;
    }
    InvokeExpr &add_arg(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->in(mDef->s64(mArgCnt), e));
        mArgCnt++;
        return *this;
    }
    InvokeExpr &set_arg(Expr::wp index, Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->in(index, e));
        return *this;
    }
    operator Expr::wp() {
        return mExpr;
    }
    Expr::wp operator() (Expr::wp exprlist) {
        Expr::sp el = exprlist.lock();
        if (el->mType == Expr::EXPRLIST) {
            size_t argCnt = 0;
            for (Expr::wp e : el->mNexts) {
                mDef->connectExpr(mExpr, mDef->in(mDef->s64(argCnt), e)); 
                argCnt++;
            }
        } else {
            mDef->connectExpr(mExpr, mDef->in(mDef->s64(0), exprlist));
        }
        return mExpr;
    }
    Expr::wp operator() () {
        return mExpr;
    }
private:
    Definition::sp mDef;
    Expr::wp mExpr;
    size_t mArgCnt;
};
class TypeExpr {
public:
    TypeExpr(Definition::sp dsp) : mDef(dsp) {
        mExpr = mDef->newExpr(Expr::TYPE);
    }
    TypeExpr &name(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->name(e));
        return *this;
    }
    TypeExpr &full_name(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->full_name(e));
        return *this;
    }
    operator Expr::wp() {
        return mExpr;
    }
#define OF_TYPE(lcname, name) \
    TypeExpr &lcname(Expr::wp type) { \
        Expr::wp wrapper = mDef->newExpr(Expr::TYPE_##name); \
        mDef->connectExpr(wrapper, type); \
        mDef->connectExpr(mExpr, wrapper); \
        return *this; \
    } \
    TypeExpr &lcname(Expr::wp depth, Expr::wp index, Expr::wp type) { \
        Expr::wp wrapper = mDef->newExpr(Expr::TYPE_##name); \
        mDef->connectExpr(wrapper, depth); \
        mDef->connectExpr(wrapper, index); \
        mDef->connectExpr(wrapper, type); \
        mDef->connectExpr(mExpr, wrapper); \
        return *this; \
    }
OF_TYPE(inner, INNER);
OF_TYPE(outer, OUTER);
OF_TYPE(base, BASE);
OF_TYPE(derived, DERIVED);
    TypeExpr &field(Expr::wp var) {
        Expr::wp field = mDef->newExpr(Expr::TYPE_FIELD);
        mDef->connectExpr(field, var);
        mDef->connectExpr(mExpr, field);
        return *this;
    }
    TypeExpr &field(Expr::wp index, Expr::wp var) {
        Expr::wp field = mDef->newExpr(Expr::TYPE_FIELD);
        mDef->connectExpr(field, index);
        mDef->connectExpr(field, var);
        mDef->connectExpr(mExpr, field);
        return *this;
    }
    TypeExpr &method(Expr::wp func) {
        Expr::wp method = mDef->newExpr(Expr::TYPE_METHOD);
        mDef->connectExpr(method, func);
        mDef->connectExpr(mExpr, method);
        return *this;
    }
    TypeExpr &method(Expr::wp index, Expr::wp func) {
        Expr::wp method = mDef->newExpr(Expr::TYPE_METHOD);
        mDef->connectExpr(method, index);
        mDef->connectExpr(method, func);
        mDef->connectExpr(mExpr, method);
        return *this;
    }
    TypeExpr &flag(Expr::wp e) { // local , global , cxx_modify_const ...
        mDef->connectExpr(mExpr, e);
        return *this;
    }
    
private:
    Definition::sp mDef;
    Expr::wp mExpr;
};

class VarExpr {
public:
    VarExpr(Definition::sp dsp) : mDef(dsp) {
        mExpr = mDef->newExpr(Expr::VARIABLE);
    }
    VarExpr &type(Expr::wp e) {
        mDef->connectExpr(mExpr, e);
        return *this;
    }
    VarExpr &name(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->name(e));
        return *this;
    }
    VarExpr &full_name(Expr::wp e) {
        mDef->connectExpr(mExpr, mDef->full_name(e));
        return *this;
    }
    VarExpr &member_of(Expr::wp type) {
        Expr::wp wrapper = mDef->newExpr(Expr::MEMBER_OF);
        mDef->connectExpr(wrapper, type);
        mDef->connectExpr(mExpr, wrapper);
        return *this;
    }
    VarExpr &flag(Expr::wp e) { // local , global , cxx_modify_const ...
        mDef->connectExpr(mExpr, e);
        return *this;
    }
    operator Expr::wp() {
        return mExpr;
    }
private:
    Definition::sp mDef;
    Expr::wp mExpr;
};
}// end of namespace vcd
#endif//DEFINITION_H
