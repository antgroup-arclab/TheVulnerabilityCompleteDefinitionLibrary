#include "Definition.h"
namespace vcd {
const char *ExprTypeNames[] {
    "OBNOT",
    "OBOR",
    "OBAND",
    "OBXOR",
    "OBLEFTSHIFT",
    "OBRIGHTSHIFT",
    "OPLUS",
    "OSUB",
    "OMULT",
    "ODIV",
    "OREM",
    "OSMOD",
    "OLT",
    "OLE",
    "OGT",
    "OGE",
    "OEQ",
    "ONOT",
    "OAND",
    "OOR",
    "OASSIGN",
    "OCAST",
    "OREAD",
    "OWRITE",
    "OPTR_READ",
    "OPTR_WRITE",
    "OINVOKE",
    "ORETURN",
    "OIF",
    "OFOR",
    "OFOR_EACH",
    "OWHILE",
    "ODO_WHILE",
    "OBREAK",
    "OCONTINUE",
    "OARRAY_ELEMENT",
    "OADDRESS",
    "OMEMBER",
    "OOFFSET_OF",
    "OSIZE_OF",
    "OTAINT",
    "BNOT",
    "BOR",
    "BAND",
    "BXOR",
    "BLEFTSHIFT",
    "BRIGHTSHIFT",
    "PLUS",
    "SUB",
    "MULT",
    "DIV",
    "REM",
    "LT",
    "LE",
    "GT",
    "GE",
    "EQ",
    "ARRAY_ELEMENT",
    "MEMBER",
    "OFFSET_OF",
    "SIZE_OF",
    "CAST",
    "NOT",
    "AND",
    "OR",
    "VOID",
    "BOOL",
    "U8",
    "U16",
    "U32",
    "U64",
    "U128",
    "S8",
    "S16",
    "S32",
    "S64",
    "S128",
    "F32",
    "F64",
    "UINTPTR",
    "BITS",
    "UTF8_STRING",
    "UTF16_STRING",
    "ARRAY",
    "POINTER",
    "RAWDATA",
    "REGEX",
    "TIMES",
    "NAME",
    "FULL_NAME",
    "TYPE",
    "TYPE_BASE",
    "TYPE_DERIVED",
    "TYPE_INNER",
    "TYPE_OUTER",
    "TYPE_FIELD",
    "TYPE_METHOD",
    "NULL_PTR",
    "UNDEFINED_ADDRESS",
    "LITERAL",
    "VALUE",
    "VARIABLE",
    "FUNCTION",
    "EXPRLIST",
    "MEMBER_OF",
    "LOCAL",
    "GLOBAL",
    "IN",
    "OUT",
    "PATH_INTERVAL",
    "PATH_CONTINUOUS",
    "NO_MORE",
    "EXIST",
    "CXX_EXTERN_C",
    "CXX_CLASS",
    "CXX_ENUM",
    "CXX_STRUCT",
    "CXX_UNION",
    "CXX_MODIFY_CONST",
    "CXX_MODIFY_EXPLICIT",
    "CXX_MODIFY_EXPORT",
    "CXX_MODIFY_EXTERN",
    "CXX_MODIFY_FRIEND",
    "CXX_MODIFY_INLINE",
    "CXX_MODIFY_MUTABLE",
    "CXX_MODIFY_NOEXCEPT",
    "CXX_MODIFY_VIRTUAL",
    "CXX_MODIFY_VOLATILE",
    "CXX_MODIFY_PRIVATE",
    "CXX_MODIFY_PROTECTED",
    "CXX_MODIFY_PUBLIC",
    "CXX_MODIFY_STATIC"
};
Expr::wp Definition::newExpr(Expr::Type type) {
    Expr::sp ne = Expr::sp(new Expr(type, mSelf));
    ne->mSelf = ne;
    mExprs.insert(ne);
    if (mTypeMap.find(type) == mTypeMap.end()) {
        Expr::wpvec v;
        v.push_back(ne);
        mTypeMap.insert(std::pair<Expr::Type, Expr::wpvec>(type, v));
    } else {
        mTypeMap[type].push_back(ne);
    }
    return ne;
}
Expr::wp Definition::copyExpr(Expr::wp o) {
    Expr::sp ne = Expr::sp(new Expr(*o.lock()));
    ne->mSelf = ne;
    mExprs.insert(ne);
    mTypeMap[ne->mType].push_back(ne);
    for (Expr::wp next : ne->mNexts) {
        Expr::sp nextsp = next.lock();
        nextsp->mPrevs.push_back(ne);

        struct ExprEdge ee;
        ee.from = ne;
        ee.to = next;
        mEdges.push_back(ee);
    }
    for (Expr::wp prev : ne->mPrevs) {
        Expr::sp prevsp = prev.lock();
        prevsp->mNexts.push_back(ne);

        struct ExprEdge ee;
        ee.from = prev;
        ee.to = ne;
        mEdges.push_back(ee);
    }
    return ne;
}
void Definition::deleteExpr(Expr::wp e) {
    Expr::sp esp = e.lock();
    auto it = mTypeMap[esp->mType].begin();
    while(it != mTypeMap[esp->mType].end()){
        if (it->lock() == esp)
            it = mTypeMap[esp->mType].erase(it);
        else
            it++;
    }
    auto vit = mEdges.begin();
    while (vit != mEdges.end()) {
        if (vit->from.lock() == esp || vit->to.lock() == esp)
            vit = mEdges.erase(vit);
        else
            vit++;
    }
    for (Expr::wp next : esp->mNexts) {
        Expr::sp nextsp = next.lock();
        auto it = nextsp->mPrevs.begin();
        while(it != nextsp->mPrevs.end()) {
            if (it->lock() == esp)
                it = nextsp->mPrevs.erase(it);
            else
                it++;
        }
    }
    for (Expr::wp prev : esp->mPrevs) {
        Expr::sp prevsp = prev.lock();
        auto it = prevsp->mNexts.begin();
        while(it != prevsp->mNexts.end()) {
            if (it->lock() == esp)
                it = prevsp->mNexts.erase(it);
            else
                it++;
        }
    }
    mExprs.erase(esp);
}
void Definition::connectExpr(Expr::wp from, Expr::wp to) {
    Expr::sp f = from.lock();
    Expr::sp t = to.lock();
    f->mNexts.push_back(to);
    t->mPrevs.push_back(from);
    struct ExprEdge ee;
    ee.from = from;
    ee.to = to;
    mEdges.push_back(ee);
}
Expr::wp oneArgExpr(Expr::Type type, Expr::wp lhs) {
    Expr::sp e = lhs.lock();
    Definition::sp d = e->mDef.lock();
    Expr::wp ret = d->newExpr(type);
    d->connectExpr(ret, lhs);
    return ret;
}
Expr::wp twoArgExpr(Expr::Type type, Expr::wp lhs, Expr::wp rhs) {
    Expr::sp e = lhs.lock();
    Definition::sp d = e->mDef.lock();
    if (e->mType == type) {
        d->connectExpr(e, rhs);
        return lhs;
    }
    Expr::wp ret = d->newExpr(type);
    d->connectExpr(ret, lhs);
    d->connectExpr(ret, rhs);
    return ret;
}
Expr::wp operator~ (Expr::wp lhs) { return oneArgExpr(Expr::BNOT, lhs);}
Expr::wp operator| (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::BOR, lhs, rhs);}
Expr::wp operator& (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::BAND, lhs, rhs);}
Expr::wp operator^ (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::BXOR, lhs, rhs);}
Expr::wp operator<<(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::BLEFTSHIFT, lhs, rhs);}
Expr::wp operator>>(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::BRIGHTSHIFT, lhs, rhs);}
Expr::wp operator+ (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::PLUS, lhs, rhs);}
Expr::wp operator- (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::SUB, lhs, rhs);}
Expr::wp operator* (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::MULT, lhs, rhs);}
Expr::wp operator/ (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::DIV, lhs, rhs);}
Expr::wp operator% (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::REM, lhs, rhs);}
Expr::wp operator< (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::LT, lhs, rhs);}
Expr::wp operator<=(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::LE, lhs, rhs);}
Expr::wp operator> (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::GT, lhs, rhs);}
Expr::wp operator>=(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::GE, lhs, rhs);}
Expr::wp operator==(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::EQ, lhs, rhs);}
Expr::wp operator! (Expr::wp lhs) { return oneArgExpr(Expr::NOT, lhs);}
Expr::wp operator!=(Expr::wp lhs, Expr::wp rhs) { return !twoArgExpr(Expr::EQ, lhs, rhs);}
Expr::wp operator&&(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::AND, lhs, rhs);}
Expr::wp operator||(Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::OR, lhs, rhs);}
Expr::wp operator, (Expr::wp lhs, Expr::wp rhs) { return twoArgExpr(Expr::EXPRLIST, lhs, rhs);}
int recursiveNotAndOrTree(Expr::sp node, Expr::spset &visitedNodes, int (*handleNode)(Expr::sp node, void *arg), void *arg) {
    if (visitedNodes.find(node) != visitedNodes.end())
        return 0;
    visitedNodes.insert(node);
    if (Expr::isConstraintLogic(node->mType)) {
        if (node->mType == Expr::NOT && node->mNexts.size() != 1) {
            printf("%p node is bad NOT node\n", node.get());
            return -1;
        }
        if ((node->mType == Expr::AND || node->mType == Expr::OR) && node->mNexts.size() < 2) {
            printf("%p node is bad AND or OR node\n", node.get());
            return -1;
        }
        for (Expr::wp nt : node->mNexts) {
            Expr::sp n = nt.lock();
            if (recursiveNotAndOrTree(n, visitedNodes, handleNode, arg) != 0) {
                printf("%p node has bad child node %p\n", node.get(), n.get());
                return -1;
            }
        }
    } else if (handleNode(node, arg) != 0) {
        printf("%p node handleNode failed\n", node.get());
        return -1;
    }
    return 0;
}
typedef bool (*isAllowedType_t)(Expr::Type type);
struct AllowedTypeHasType {
    isAllowedType_t isAllowedType;
    bool hasType;
};
int handleNodeByAllowedType(Expr::sp node, void *arg) {
    struct AllowedTypeHasType *data = (struct AllowedTypeHasType *)arg;
    if (data->isAllowedType(node->mType) == false) {
        printf("%p node is not allowed type. real type %d require %p\n",
                node.get(), node->mType, data->isAllowedType);
        return -1;
    }
    data->hasType = true;
    return 0;
}
int validateNodeByAllowedType(Expr::sp node, isAllowedType_t isAllowedType) {
    Expr::spset innerVisitedNodes;
    AllowedTypeHasType arg;
    arg.isAllowedType = isAllowedType;
    arg.hasType = false;
    if (recursiveNotAndOrTree(node, innerVisitedNodes, handleNodeByAllowedType, (void *)&arg) != 0) {
        printf("%p node has bad node when recursiveNotAndOrTree\n",
                node.get());
        return -1;
    }
    if (arg.hasType == false) {
        printf("%p node has no allowed type after recursiveNotAndOrTree\n",
                node.get());
        return -1;
    }
    return 0;
}
int validateChildNodeByAllowedType(Expr::sp node, std::vector<isAllowedType_t> &isAllowedTypes) {
    if (node->mNexts.size() != isAllowedTypes.size()) {
        printf("%p node has incorrect child node count. real %lu require %lu\n",
                node.get(), node->mNexts.size(), isAllowedTypes.size());
        return -1;
    }
    size_t i;
    for (i = 0; i < isAllowedTypes.size(); ++i) {
        Expr::sp n = node->mNexts[i].lock();
        if (validateNodeByAllowedType(n, isAllowedTypes[i]) != 0) {
            printf("%p node's child node %p is not valid by %p\n",
                    node.get(), n.get(), isAllowedTypes[i]);
            return -1;
        }
    }
    return 0;
}
int validate_NoNext(Expr::sp node) {
    if (node->mNexts.size() != 0)
        return -1;
    return 0;
}
int validate_VARIABLE(Expr::sp node) {
    size_t nameCnt = 0, memberOfCnt = 0;
    for (Expr::wp nt : node->mNexts) {
        Expr::sp n = nt.lock();
        if (n->mType != Expr::NAME
                && n->mType != Expr::FULL_NAME
                && n->mType != Expr::MEMBER_OF
                && !Expr::isCXX(n->mType)
                && n->mType != Expr::NO_MORE) {
            printf("%p function has incorrect child node %p\n", node.get(), n.get());
            return -1;
        }
        if (n->mType == Expr::NAME || n->mType == Expr::FULL_NAME) {
            nameCnt++;
            if (nameCnt > 1) {
                printf("%p function only allow one name\n", node.get());
                return -1;
            }
        } else if (n->mType == Expr::MEMBER_OF) {
            memberOfCnt++;
            if (memberOfCnt > 1) {
                printf("%p function only allow one member_of\n", node.get());
                return -1;
            }
        }
    }
    return 0;
}
int validate_FUNCTION(Expr::sp node) {
    size_t nameCnt = 0, memberOfCnt = 0, pathCnt = 0;
    for (Expr::wp nt : node->mNexts) {
        Expr::sp n = nt.lock();
        if (n->mType != Expr::IN 
                && n->mType != Expr::OUT
                && n->mType != Expr::NAME
                && n->mType != Expr::FULL_NAME
                && n->mType != Expr::MEMBER_OF
                && n->mType != Expr::PATH_INTERVAL
                && !Expr::isCXX(n->mType)
                && n->mType != Expr::NO_MORE) {
            printf("%p function has incorrect child node %p\n", node.get(), n.get());
            return -1;
        }
        if (n->mType == Expr::NAME || n->mType == Expr::FULL_NAME) {
            nameCnt++;
            if (nameCnt > 1) {
                printf("%p function only allow one name\n", node.get());
                return -1;
            }
        } else if (n->mType == Expr::MEMBER_OF) {
            memberOfCnt++;
            if (memberOfCnt > 1) {
                printf("%p function only allow one member_of\n", node.get());
                return -1;
            }
        } else if (n->mType == Expr::PATH_INTERVAL) {
            pathCnt++;
            if (pathCnt > 1) {
                printf("%p function only allow one path_interval\n", node.get());
                return -1;
            }
        }
    }
    return 0;
}
int validate_TYPE(Expr::sp node) {
    size_t nameCnt = 0;
    for (Expr::wp nt : node->mNexts) {
        Expr::sp n = nt.lock();
        if (n->mType != Expr::TYPE_BASE
                && n->mType != Expr::TYPE_DERIVED
                && n->mType != Expr::TYPE_INNER
                && n->mType != Expr::TYPE_OUTER
                && n->mType != Expr::TYPE_FIELD
                && n->mType != Expr::TYPE_METHOD
                && n->mType != Expr::NAME
                && n->mType != Expr::FULL_NAME
                && !Expr::isCXX(n->mType)
                && n->mType != Expr::NO_MORE) {
            printf("%p complex type has incorrect child node %p\n", node.get(), n.get());
            return -1;
        }
        if (n->mType == Expr::NAME || n->mType == Expr::FULL_NAME) {
            nameCnt++;
            if (nameCnt > 1) {
                printf("%p function only allow one name\n", node.get());
                return -1;
            }
        }
    }
    return 0;
}
int validate_OINVOKE(Expr::sp node) {
    if (node->mNexts.size() < 1) {
        printf("%p invoke need function expr\n", node.get());
        return -1;
    }
    if (validateNodeByAllowedType(node->mNexts[0].lock(), Expr::isFunctionOrExist) != 0) {
        printf("%p invoke first child must be FUNCTION\n", node.get());
        return -1;
    }
    size_t i;
    for (i = 1; i < node->mNexts.size(); ++i) {
        Expr::sp n = node->mNexts[i].lock();
        if (n->mType != Expr::IN) {
            printf("%p invoke only allow IN node, bad node is %p\n", node.get(), n.get());
            return -1;
        }
    }
    return 0;
}
struct HasPathConstraintOperation {
    bool hasPath;
    bool hasConstraint;
    bool hasOperation;
};
int handleNodeFromPath(Expr::sp node, void *arg) {
    struct HasPathConstraintOperation *data = (struct HasPathConstraintOperation *)arg;
    if (node->mType == Expr::EXIST)
        return 0;
    if (Expr::isOperation(node->mType)) {
        if (data->hasConstraint) {
            printf("%p detected Conflict. Already hasConstraint\n", node.get());
            return -1;
        }
        data->hasOperation = true;
        return 0;
    } else if (Expr::isConstraintCalculate(node->mType)) {
        if (data->hasOperation) {
            printf("%p detected Conflict. Already hasOperation\n", node.get());
            return -1;
        }
        data->hasConstraint = true;
        return 0;
    } else if (node->mType == Expr::PATH_INTERVAL || node->mType == Expr::PATH_CONTINUOUS) {
        data->hasPath = true;
        return 0;
    }
    printf("%p node bad type %d\n", node.get(), node->mType);
    return -1;
}
int validate_PATH(Expr::sp node) {
    if (node->mNexts.size() != 1) {
        printf("%p node only allow one child\n", node.get());
        return -1;
    }
    Expr::sp child = node->mNexts[0].lock();
    if (child->mType == Expr::EXPRLIST) {
        for (Expr::wp cd : child->mNexts) {
            Expr::sp c = cd.lock();
            Expr::spset innerVisitedNodes;
            struct HasPathConstraintOperation arg;
            arg.hasPath = false;
            arg.hasConstraint = false;
            arg.hasOperation = false;
            if (recursiveNotAndOrTree(c, innerVisitedNodes, handleNodeFromPath, (void *)&arg) != 0) {
                printf("%p node has bad node when recursiveNotAndOrTree\n",
                        node.get());
                return -1;
            }
            if (arg.hasPath == false && arg.hasConstraint == false && arg.hasOperation == false) {
                printf("%p node has no correct type after recursiveNotAndOrTree\n",
                        node.get());
                return -1;
            }
        }
    } else {
        Expr::spset innerVisitedNodes;
        struct HasPathConstraintOperation arg;
        arg.hasPath = false;
        arg.hasConstraint = false;
        arg.hasOperation = false;
        if (recursiveNotAndOrTree(child, innerVisitedNodes, handleNodeFromPath, (void *)&arg) != 0) {
            printf("%p node has bad node when recursiveNotAndOrTree\n",
                    node.get());
            return -1;
        }
        if (arg.hasPath == false && arg.hasConstraint == false && arg.hasOperation == false) {
            printf("%p node has no correct type after recursiveNotAndOrTree\n",
                    node.get());
            return -1;
        }
    }
    return 0;
}
int validateNode(Expr::sp node, Expr::spset &visitedNodes) {
    if (visitedNodes.find(node) != visitedNodes.end())
        return 0;
printf("validating node %p type %d\n", node.get(), node->mType);
    switch(node->mType) {
    case Expr::OBNOT:
    case Expr::ONOT:
    case Expr::OREAD:
    case Expr::OWRITE:
    case Expr::ORETURN:
    case Expr::OTAINT:
    case Expr::OADDRESS:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
        
    case Expr::BNOT:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isConstraintCalculateOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::OBOR:
    case Expr::OBAND:
    case Expr::OBXOR:
    case Expr::OBLEFTSHIFT:
    case Expr::OBRIGHTSHIFT:
    case Expr::OPLUS:
    case Expr::OSUB:
    case Expr::OMULT:
    case Expr::ODIV:
    case Expr::OREM:
    case Expr::OSMOD:
    case Expr::OLT:
    case Expr::OLE:
    case Expr::OGT:
    case Expr::OGE:
    case Expr::OEQ:
    case Expr::OAND:
    case Expr::OOR:
    case Expr::OASSIGN:
    case Expr::OARRAY_ELEMENT:
    case Expr::OMEMBER:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
        isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::BOR:
    case Expr::BAND:
    case Expr::BXOR:
    case Expr::BLEFTSHIFT:
    case Expr::BRIGHTSHIFT:
    case Expr::PLUS:
    case Expr::SUB:
    case Expr::MULT:
    case Expr::DIV:
    case Expr::REM:
    case Expr::LT:
    case Expr::LE:
    case Expr::GT:
    case Expr::GE:
    case Expr::EQ:
    case Expr::ARRAY_ELEMENT:
    case Expr::MEMBER:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isConstraintCalculateOrOperandOrExist);
        isAllowedTypes.push_back(Expr::isConstraintCalculateOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::NOT:
    {
        if (node->mNexts.size() != 1) {
            printf("%p node bad NOT\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::AND:
    case Expr::OR:
    case Expr::EXPRLIST:
    {
        if (node->mNexts.size() < 2) {
            printf("%p node bad AND or OR\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::OPTR_READ:
    case Expr::OPTR_WRITE:
    {
        if (node->mNexts.size() == 1) {
            std::vector<isAllowedType_t> isAllowedTypes;
            isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
            if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                printf("%p node has bad child\n", node.get());
                return -1;
            }
        } else if (node->mNexts.size() == 2) {
            std::vector<isAllowedType_t> isAllowedTypes;
            isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
            isAllowedTypes.push_back(Expr::isS64OrExist);
            if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                printf("%p node has bad child\n", node.get());
                return -1;
            }
        } else {
            printf("%p node bad OPTR_READ or OPTR_WRITE\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::OINVOKE:
        if (validate_OINVOKE(node) != 0)
            return -1;
        break;
    case Expr::OIF:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isOCompareOrExist);
        isAllowedTypes.push_back(Expr::isPathOrExist);
        isAllowedTypes.push_back(Expr::isPathOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::OWHILE:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isOCompareOrExist);
        isAllowedTypes.push_back(Expr::isPathOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::OFOR:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isPathOrExist);
        isAllowedTypes.push_back(Expr::isOCompareOrExist);
        isAllowedTypes.push_back(Expr::isPathOrExist);
        isAllowedTypes.push_back(Expr::isPathOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::OFOR_EACH:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
        isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
        isAllowedTypes.push_back(Expr::isPathOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::ODO_WHILE:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isPathOrExist);
        isAllowedTypes.push_back(Expr::isOCompareOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::OBREAK:
    case Expr::OCONTINUE:

    case Expr::VOID:
    case Expr::BOOL:
    case Expr::U8:
    case Expr::U16:
    case Expr::U32:
    case Expr::U64:
    case Expr::U128:
    case Expr::S8:
    case Expr::S16:
    case Expr::S32:
    case Expr::S64:
    case Expr::S128:
    case Expr::F32:
    case Expr::F64:
    case Expr::UTF8_STRING:
    case Expr::UTF16_STRING:

    case Expr::NULL_PTR:
    case Expr::UNDEFINED_ADDRESS:

    case Expr::REGEX:
    case Expr::LOCAL:
    case Expr::GLOBAL:

    case Expr::NO_MORE:
    case Expr::EXIST:

    case Expr::CXX_EXTERN_C:
    case Expr::CXX_CLASS:
    case Expr::CXX_ENUM:
    case Expr::CXX_STRUCT:
    case Expr::CXX_UNION:
    case Expr::CXX_MODIFY_CONST:
    case Expr::CXX_MODIFY_EXPLICIT:
    case Expr::CXX_MODIFY_EXPORT:
    case Expr::CXX_MODIFY_EXTERN:
    case Expr::CXX_MODIFY_FRIEND:
    case Expr::CXX_MODIFY_INLINE:
    case Expr::CXX_MODIFY_MUTABLE:
    case Expr::CXX_MODIFY_NOEXCEPT:
    case Expr::CXX_MODIFY_VIRTUAL:
    case Expr::CXX_MODIFY_VOLATILE:
    case Expr::CXX_MODIFY_PRIVATE:
    case Expr::CXX_MODIFY_PROTECTED:
    case Expr::CXX_MODIFY_PUBLIC:
    case Expr::CXX_MODIFY_STATIC:
        if (validate_NoNext(node) != 0) {
            printf("%p node type %d should has no child\n", node.get(), node->mType);
            return -1;
        }
        break;

    case Expr::OOFFSET_OF:
    case Expr::OFFSET_OF:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isComplexTypeOrOperandOrExist);
        isAllowedTypes.push_back(Expr::isVarOrFuncOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::OCAST:
    case Expr::CAST:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isTypeOrOperandOrExist);
        isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::MEMBER_OF:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isComplexTypeOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::OSIZE_OF:
    case Expr::SIZE_OF:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isTypeOrOperationOrOperandOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::VARIABLE:
        if (validate_VARIABLE(node) != 0)
            return -1;
        break;
    case Expr::FUNCTION:
        if (validate_FUNCTION(node) != 0)
            return -1;
        break;

    case Expr::PATH_INTERVAL :
    case Expr::PATH_CONTINUOUS:
        if (validate_PATH(node) != 0)
            return -1;
        break;
    case Expr::VALUE:
    {
        if (node->mNexts.size() == 0)
            break;
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isTypeOrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::NAME:
    case Expr::FULL_NAME:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isUTF8OrRegex);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    case Expr::IN:
    case Expr::OUT:
    {
        if (node->mNexts.size() == 1) {
            if (node->mNexts[0].lock()->mType != Expr::NO_MORE) {
                std::vector<isAllowedType_t> isAllowedTypes;
                isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
                if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                    printf("%p node has bad child\n", node.get());
                    return -1;
                }
            }
            break;
        } else if (node->mNexts.size() == 2) {
            std::vector<isAllowedType_t> isAllowedTypes;
            isAllowedTypes.push_back(Expr::isS64OrExist);
            isAllowedTypes.push_back(Expr::isOperationOrOperandOrExist);
            if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                printf("%p node has bad child\n", node.get());
                return -1;
            }
            break;
        } else {
            printf("%p bad IN or OUT node\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::TIMES:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isS64OrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::TYPE:
        if (validate_TYPE(node) != 0)
            return -1;
        break;
    case Expr::TYPE_BASE:
    case Expr::TYPE_DERIVED:
    case Expr::TYPE_INNER:
    case Expr::TYPE_OUTER:
    {
        if (node->mNexts.size() == 1) {
            if (node->mNexts[0].lock()->mType != Expr::NO_MORE) {
                std::vector<isAllowedType_t> isAllowedTypes;
                isAllowedTypes.push_back(Expr::isComplexTypeOrExist);
                if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                    printf("%p node has bad child\n", node.get());
                    return -1;
                }
            }
            break;
        } else if (node->mNexts.size() == 3) {
            std::vector<isAllowedType_t> isAllowedTypes;
            isAllowedTypes.push_back(Expr::isS64OrExist);
            isAllowedTypes.push_back(Expr::isS64OrExist);
            isAllowedTypes.push_back(Expr::isComplexTypeOrExist);
            if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                printf("%p node has bad child\n", node.get());
                return -1;
            }
            break;
        } else {
            printf("%p bad TYPE node\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::TYPE_FIELD:
    {
        if (node->mNexts.size() == 1) {
            if (node->mNexts[0].lock()->mType != Expr::NO_MORE) {
                std::vector<isAllowedType_t> isAllowedTypes;
                isAllowedTypes.push_back(Expr::isVariableOrExist);
                if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                    printf("%p node has bad child\n", node.get());
                    return -1;
                }
            }
        } else if (node->mNexts.size() == 2) {
            std::vector<isAllowedType_t> isAllowedTypes;
            isAllowedTypes.push_back(Expr::isS64OrExist);
            isAllowedTypes.push_back(Expr::isVariableOrExist);
            if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                printf("%p node has bad child\n", node.get());
                return -1;
            }
        } else {
            printf("%p bad TYPE_FIELD node\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::TYPE_METHOD:
    {
        if (node->mNexts.size() == 1) {
            if (node->mNexts[0].lock()->mType != Expr::NO_MORE) {
                std::vector<isAllowedType_t> isAllowedTypes;
                isAllowedTypes.push_back(Expr::isFunctionOrExist);
                if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                    printf("%p node has bad child\n", node.get());
                    return -1;
                }
            }
        } else if (node->mNexts.size() == 2) {
            std::vector<isAllowedType_t> isAllowedTypes;
            isAllowedTypes.push_back(Expr::isS64OrExist);
            isAllowedTypes.push_back(Expr::isFunctionOrExist);
            if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
                printf("%p node has bad child\n", node.get());
                return -1;
            }
        } else {
            printf("%p bad TYPE_FIELD node\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::LITERAL:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isBasicType);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }
    case Expr::BITS:
    {
        std::vector<isAllowedType_t> isAllowedTypes;
        isAllowedTypes.push_back(Expr::isS64OrExist);
        if (validateChildNodeByAllowedType(node, isAllowedTypes) != 0) {
            printf("%p node has bad child\n", node.get());
            return -1;
        }
        break;
    }

    default:
        printf("%p bad node type %d\n", node.get(), node->mType);
        return -1;
    }
    visitedNodes.insert(node);
    for (Expr::wp cd : node->mNexts) {
        Expr::sp c = cd.lock();
        if (validateNode(c, visitedNodes) != 0)
            return -1;
    }
    return 0;
}
Expr::sp Definition::getRoot() {
    if (mTypeMap.find(Expr::PATH_INTERVAL) == mTypeMap.end()) {
        printf("definition must has one PATH_INTERVAL expr\n");
        return Expr::sp();
    }
    Expr::sp root;
    size_t root_cnt = 0;
    for (Expr::wp pi : mTypeMap[Expr::PATH_INTERVAL]) {
        Expr::sp p = pi.lock();
        if (p->mPrevs.size() == 0) {
            root = p;
            root_cnt++;
        }
    }
    if (root_cnt != 1) {
        printf("defintion only allow one root path\n");
        return Expr::sp();
    }
    return root;
}
int Definition::validate() {
    Expr::sp root = getRoot();
    if (root.get() == nullptr) {
        printf("getRoot failed\n");
        return -1;
    }
    Expr::spset visitedNodes;
    return validateNode(root, visitedNodes);
}
void Definition::printRawExpr() {
    for (Expr::sp e : mExprs) {
        printf("id: %p type: %d %s\n    payload_size: %lu payload: ",
                e.get(), e->mType, ExprTypeNames[e->mType], e->mPayload.size());
        for(uint8_t n : e->mPayload) {
            printf("%02x", n);
        }
        printf(" as_str: ");
        for(uint8_t n : e->mPayload) {
            printf("%c", (char)n);
        }
        printf("\n");
        printf("    nexts:");
        for (Expr::wp n: e->mNexts) {
            printf(" %p", n.lock().get());
        }
        printf("\n");
        printf("    prevs:");
        for (Expr::wp p: e->mPrevs) {
            printf(" %p", p.lock().get());
        }
        printf("\n");
    }
}
int recursivePrint(Expr::sp node, Expr::spset &visitedNodes, int spaceCnt) {
    printf("%*s%p %s", 
            spaceCnt, "", node.get(), ExprTypeNames[node->mType]);
    if (node->mType == Expr::UTF8_STRING || node->mType == Expr::REGEX)
        printf("  %s\n", node->mPayload.data());
    else if (node->mType == Expr::S64 && node->mPayload.size() == sizeof(int64_t))
        printf("  %lld\n", *(int64_t *)node->mPayload.data());
    else
        printf("\n");
    if (visitedNodes.find(node) != visitedNodes.end())
        return 0;
    visitedNodes.insert(node);
    for (Expr::wp nt : node->mNexts) {
        Expr::sp n = nt.lock();
        if (recursivePrint(n, visitedNodes, spaceCnt + 2) != 0)
            return -1;
    }
    return 0;
}
void Definition::printTree() {
    Expr::sp root;
    if (mTypeMap.find(Expr::PATH_INTERVAL) == mTypeMap.end()) {
        printf("definition must has one PATH_INTERVAL expr\n");
        return;
    }
    size_t root_cnt = 0;
    for (Expr::wp pi : mTypeMap[Expr::PATH_INTERVAL]) {
        Expr::sp p = pi.lock();
        if (p->mPrevs.size() == 0) {
            root = p;
            root_cnt++;
        }
    }
    if (root_cnt != 1) {
        printf("defintion only allow one root path\n");
        return;
    }
    Expr::spset visitedNodes;
    recursivePrint(root, visitedNodes, 0);
}
}// end of namespace vcd
